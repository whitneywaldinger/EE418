class EMAPoracle:
    def __init__(self, k, IDP, ID, K1, K2, K3, K4):
        self.k = k
        self.IDP = IDP
        self.ID = ID
        self.K1 = K1
        self.K2 = K2
        self.K3 = K3
        self.K4 = K4

    def Fp(self, x):
        # Divide x into 4-bit blocks and XOR the bits in each block
        result = ""
        for i in range(0, len(x), 4):
            block = x[i:i+4]
            xor_result = int(block[0])
            for bit in block[1:]:
                xor_result ^= int(bit)
            result += str(xor_result)
        return result

    def protocolRun1(self):
        n1 = generateRandomString(self.k)
        n2 = generateRandomString(self.k)

        A = bxor(bxor(self.IDP, self.K1), n1)
        B = bxor(bor(self.IDP, self.K2), n1)
        C = bxor(bxor(self.IDP, self.K3), n2)

        computed_n1 = bxor(bxor(A, self.IDP), self.K1)
        computed_n2 = bxor(bxor(C, self.IDP), self.K3)

        if B == bxor(band(self.IDP, self.K2), computed_n1):
            # Authentication successful
            D = bxor(band(self.IDP, self.K4), computed_n2)
            E = bxor(bxor(bor(band(self.IDP, n1), n2), self.ID), bxor(bxor(self.K1, self.K2), bxor(self.K3, self.K4)))
            
            # Update keys
            ID1_48 = self.ID[:self.k // 2]  # Assuming k is even and sufficient for the ID
            ID49_96 = self.ID[self.k // 2:]
            self.IDP = bxor(self.IDP, bxor(n2, self.K1))
            self.K1 = bxor(self.K1, bxor(n2, self.Fp(self.K4) + self.Fp(self.K3) + ID1_48))
            self.K2 = bxor(self.K2, bxor(n2, self.Fp(self.K1) + self.Fp(self.K4) + ID49_96))
            self.K3 = bxor(self.K3, bxor(n1, ID1_48 + self.Fp(self.K4) + self.Fp(self.K2)))
            self.K4 = bxor(self.K4, bxor(n1, self.Fp(self.K3) + self.Fp(self.K1) + ID49_96))

            return {'A': A, 'B': B, 'C': C, 'D': D, 'E': E}
        else:
            # Authentication failed
            return None

    def verifyID(self, given_ID):
        return self.ID == given_ID
